import type { IData, ILegendItem, IMargin, IScale, ITheme } from "@chart-it/types";

import type { IChartState, IChartStateDimensions, IChartStateLegend, IChartStateScales, IState } from "../types";
import { PROGRESSIVE_RENDER_THRESHOLD } from "../../constants";

const EMPTY_ARRAY = [];
const EMPTY_MARGIN = { left: 0, right: 0, top: 0, bottom: 0 };

interface IChartSelectors {
    store: (state: IState) => IChartState;
    data: (state: IState) => IData;
    animationDuration: (state: IState) => number;
    scales: {
        store: (state: IState) => IChartStateScales;
        getScale: (state: IState, field: string) => IScale | undefined;
        getAxisScale: (state: IState, field: string) => IScale | undefined;
    };
    dimensions: {
        store: (state: IState) => IChartStateDimensions;
        width: (state: IState) => number;
        height: (state: IState) => number;
        margin: (state: IState) => IMargin;
    };
    legend: {
        store: (state: IState) => IChartStateLegend;
        isVisible: (state: IState) => boolean;
        items: (state: IState) => ILegendItem[];
    };
    theme: (state: IState) => ITheme;
}

export const chartSelectors: IChartSelectors = {
    /**
     * Returns the store for the chart part of state
     * @param  state The application state
     * @return       The state
     */
    store: (state: IState): IChartState => state.chart,

    /**
     * Returns the data for the chart
     * @param  state The application state
     * @return       The chart data
     */
    data: (state: IState): IData => chartSelectors.store(state).data || EMPTY_ARRAY,

    /**
     * Returns the duration to run animations for
     * @param  state The application state
     * @return       The duration in milliseconds
     */
    animationDuration: (state: IState): number => {
        const animationDuration = chartSelectors.store(state).animationDuration;
        const data = chartSelectors.data(state);

        // If we have a large dataset, then we're going to default
        // automatically to no animations
        if (data.length && data.length > PROGRESSIVE_RENDER_THRESHOLD) {
            return 0;
        }

        return animationDuration || 0;
    },

    /**
     * Represents the scales that the chart uses
     */
    scales: {
        store: (state: IState): IChartStateScales => chartSelectors.store(state).scales,

        /**
         * Return a scale based on the field
         * @param  state           The application state
         * @param  field           The field to get the scale of
         * @return                 The d3.Scale function
         */
        getScale: (state: IState, field: string): IScale | undefined => {
            const store = chartSelectors.store(state);

            // Manually defined scales take precent
            const scales = store.scales || {};
            if (scales[field]) {
                return scales[field];
            }

            // Automatic scales generated by axis are the fallback
            const axisScales = store.axisScales || {};
            if (axisScales[field]) {
                return axisScales[field];
            }

            return undefined;
        },

        /**
         * Return a scale based on the field, preferring an Axis scale
         * @param  state           The application state
         * @param  field           The field to get the scale of
         * @return                 The d3.Scale function
         */
        getAxisScale: (state: IState, field: string): IScale | undefined => {
            const store = chartSelectors.store(state);

            // Axis scale takes precedent
            const axisScales = store.axisScales || {};
            if (axisScales[field]) {
                return axisScales[field];
            }

            // Manually defined scales
            const scales = store.scales || {};
            if (scales[field]) {
                return scales[field];
            }

            return undefined;
        },
    },

    /**
     * Returns dimension based information for the chart
     */
    dimensions: {
        store: (state: IState): IChartStateDimensions => chartSelectors.store(state).dimensions,

        /**
         * Returns the width of the chart
         * @param  state The application state
         * @return       The width
         */
        width: (state: IState): number => chartSelectors.dimensions.store(state).width || 0,

        /**
         * Returns the height of the chart
         * @param  state The application state
         * @return       The height
         */
        height: (state: IState): number => chartSelectors.dimensions.store(state).height || 0,

        /**
         * Returns the margin of the chart
         * @param  state The application state
         * @return       The margin
         */
        margin: (state: IState): IMargin => chartSelectors.dimensions.store(state).margin || EMPTY_MARGIN,
    },

    /**
     * Returns legend information for the chart
     */
    legend: {
        store: (state: IState): IChartStateLegend => chartSelectors.store(state).legend,

        /**
         * Should the legend be visible?
         * @param  state     The application state
         * @return           True if the legend should be visible
         */
        isVisible: (state: IState): boolean => chartSelectors.legend.items(state).length > 1,

        /**
         * Returns the set of items required to be in the legend
         * @param  state     The application state
         * @return           The items for the legend to render
         */
        items: (state: IState): ILegendItem[] => chartSelectors.legend.store(state).items || EMPTY_ARRAY,
    },

    /**
     * Returns the theme for the chart
     * @param  state The application state
     * @return The theme object
     */
    theme: (state: IState): ITheme => chartSelectors.store(state).theme,
};
