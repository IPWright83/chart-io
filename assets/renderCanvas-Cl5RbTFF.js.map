{"version":3,"file":"renderCanvas-Cl5RbTFF.js","sources":["../../src/lib/hoc/canvas/canvasRenderLoop.ts","../../src/lib/hoc/canvas/progressiveCanvasRenderLoop.ts","../../src/lib/hoc/canvas/index.ts","../../src/lib/components/Plots/renderCanvas.ts"],"sourcesContent":["import { d3 } from \"@chart-io/core\";\n\nimport { renderElements } from \"./renderElements\";\n\n/**\n * Start a render loop for drawing on the canvas during some animations\n * @param  canvas         The canvas element\n * @param  width          The width of the canvas\n * @param  height         The height of the canvas\n * @param  exit           The D3 data update join\n * @param  update         The D3 data exit join\n */\nexport async function canvasRenderLoop(\n    canvas: HTMLCanvasElement | null | undefined,\n    width: number,\n    height: number,\n    exit: d3.Transition<Element, unknown, any, unknown>,\n    update: d3.Transition<Element, unknown, any, unknown>,\n) {\n    // If the canvas isn't ready don't do anything\n    if (!canvas) {\n        // istanbul ignore next\n        return;\n    }\n\n    // Ensure we've got the contexts to draw upon\n    const context = canvas.getContext(\"2d\");\n\n    const render = () => {\n        context.clearRect(0, 0, width, height);\n        renderElements(context, exit);\n        renderElements(context, update);\n    };\n\n    // Create a render loop that will run until the transitions complete\n    const renderLoop = d3.timer(render);\n\n    try {\n        await exit.end();\n        // eslint-disable-next-line no-empty\n    } catch (e) {}\n    try {\n        await update.end();\n        // eslint-disable-next-line no-empty\n    } catch (e) {}\n\n    // Run 1 final render after animations have finished\n    renderLoop.stop();\n    render();\n}\n","import { d3 } from \"@chart-io/core\";\n\nimport { renderElements } from \"./renderElements\";\n\n/**\n * Start a render loop for drawing on the canvas during some animations\n * @param  canvas         The canvas element\n * @param  width          The width of the canvas\n * @param  height         The height of the canvas\n * @param  exit           The D3 data update join\n * @param  update         The D3 data exit join\n */\nexport async function progressiveCanvasRenderLoop(\n    canvas: HTMLCanvasElement | null | undefined,\n    width: number,\n    height: number,\n    exit: d3.Transition<Element, unknown, any, unknown>,\n    update: d3.Transition<Element, unknown, any, unknown>\n) {\n    // If the canvas isn't ready don't do anything\n    if (!canvas) {\n        return;\n    }\n\n    // Ensure we've got the contexts to draw upon\n    const context = canvas.getContext(\"2d\");\n\n    // Wait for the transitions to complete. These should be\n    // set to have a duration of 0 so should complete after\n    // the next async tick\n    try {\n        await update.end();\n        // eslint-disable-next-line no-empty\n    } catch (e) {}\n\n    context.clearRect(0, 0, width, height);\n\n    const nodes = update.nodes();\n\n    const renderLoop = d3.timer(() => {\n        // Cancel the render loop\n        if (nodes.length === 0) {\n            renderLoop.stop();\n            return;\n        }\n\n        // Grab the next batch of nodes and render them\n        const batch = nodes.splice(0, 1000);\n\n        // @ts-expect-error: Extending the interface on purpose\n        batch.each = batch.forEach;\n\n        // @ts-ignore: Not really sure what this means\n        renderElements(context, batch);\n    });\n}\n","export * from \"./canvasRenderLoop\";\nexport * from \"./progressiveCanvasRenderLoop\";\n","import { d3, PROGRESSIVE_RENDER_THRESHOLD } from \"@chart-io/core\";\n\nimport { canvasRenderLoop, progressiveCanvasRenderLoop } from \"../../hoc/canvas\";\n\n/**\n * Renders to a canvas if one is provided\n * @param  canvas                  The HTML canvas (or null if we're not rendering to one)\n * @param  renderVirtualCanvas     Should a virtual canvas for events be rendered?\n * @param  width                   The width of the chart\n * @param  height                  The height of the chart\n * @param  update                  The update selection\n * @param  exit                    The exit selection\n * @return                         A promise that resolves once the rendering has completed\n */\nexport async function renderCanvas(\n    canvas: HTMLCanvasElement | null | undefined,\n    renderVirtualCanvas: any,\n    width: number,\n    height: number,\n    update: d3.Transition<Element, unknown, any, unknown>,\n    exit?: d3.Transition<Element, unknown, any, unknown>,\n) {\n    if (!canvas) {\n        return;\n    }\n\n    // If the dataset is large then we'll progressively render it. This means we're going\n    // to render it in batches, to keep the browser performant, at the expense of supporting events\n    if (update.size() > PROGRESSIVE_RENDER_THRESHOLD) {\n        return await progressiveCanvasRenderLoop(canvas, width, height, exit, update);\n    }\n\n    // Render to the plots canvas\n    await canvasRenderLoop(canvas, width, height, exit, update);\n\n    // If a virtual canvas is being used for event, render that at the end\n    if (renderVirtualCanvas) {\n        renderVirtualCanvas(update);\n    }\n}\n"],"names":["canvasRenderLoop","canvas","width","exit","update","cov_1ji875t3i9","f","s","b","height","cov_17hkahujtj","cov_2i1251yiiy","actualCoverage","cov_9inonn6pt"],"mappings":"29EAAA,EAmC0B,eAAAA,EAElBC,EACAC,IAESC,EACTC,EACA,CAES,GAFTC,EAAA,EAAAC,OAAAD,EAAA,EAAAE,EAES,CAAA,IAAAN,EAKjBI,IAAAG,cALiB,CAAAH,EAAAG,EAAAA,UAAAH,EAAA,EAAAE,EAIN,CAAA,IAAA,MACX,w9FCVUN,EAEEC,EACAO,EACAN,EACJC,EAGA,CAMA,GANAM,IAAAJ,EAAA,CAAA,IAAAI,EAAA,EAAAH,EAMA,CAAA,IAAAN,EAERS,EAAA,EAAAF,cAFQ,CAAAE,EAAA,EAAAF,EAAAE,CAAAA,EAAAA,CAAAA,IAAAA,IAAAH,OACH,MACL,sgCCvDA,OAAAI,EAAA,UAAA,CAAA,OAAAC,CAAA,EAAAA,CAAA,CAAAD,EAAA,+lECAA,OAAAE,EAAA,UAAA,CAAA,OAAAD,CAAA,EAAAA,CAAA,CAAAC,EAAA"}