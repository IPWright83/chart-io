{"version":3,"file":"storybook-CmUtk8-_.js","sources":["../../src/lib/testUtils/storybook.ts"],"sourcesContent":["import { expect, fireEvent } from \"@storybook/test\";\n\nimport { wait } from \"./wait\";\n\ninterface IMouseCoords {\n    clientX: number;\n    clientY: number;\n}\n\nexport interface ITestArgs {\n    canvasElement: HTMLElement;\n    args: {\n        onMouseOver: (event: MouseEvent) => void;\n        onMouseOut: (event: MouseEvent) => void;\n        onClick: (event: MouseEvent) => void;\n    };\n}\n\nconst STORYBOOK_PLAY_DELAY = 800;\n\n/**\n * Creates an interaction test for an SVG chart\n * @param selector  The CSS selector to use to grab an data point\n * @param event     An object containing the mouse coordinates\n * @returns         The Storybook play function\n */\nexport const createSVGTest =\n    (selector: string, event: IMouseCoords) =>\n        /**\n         * The actual test\n         * @param { canvasElement, args } The storybook play function interface\n         */\n        async ({ canvasElement, args }: ITestArgs) => {\n            const eventArgs = { ...event, bubbles: true };\n\n            // Wait for the chart to finish rendering\n            await wait(STORYBOOK_PLAY_DELAY);\n\n            // Grab a point\n            const dataPoint = canvasElement.querySelector(selector);\n            expect(dataPoint).toBeDefined();\n\n            fireEvent(dataPoint, new MouseEvent(\"mouseover\", eventArgs));\n            expect(args.onMouseOver).toHaveBeenCalled();\n\n            fireEvent(dataPoint, new MouseEvent(\"click\", eventArgs));\n            expect(args.onClick).toHaveBeenCalled();\n\n            fireEvent(dataPoint, new MouseEvent(\"mouseout\", eventArgs));\n            expect(args.onMouseOut).toHaveBeenCalled();\n\n            // Add the tooltip back to verify it\n            fireEvent(dataPoint, new MouseEvent(\"mouseover\", eventArgs));\n            expect(args.onMouseOver).toHaveBeenCalled();\n        };\n\n/**\n * Creats an interaction test for the EventReciever in an SVG chart\n * @param event             An object containing the mouse coordinates\n * @param postAssertions    A function to run extra assertions after the mouse events have fired\n * @returns                 The Storybook play function\n */\nexport const createEventReceiverTest =\n    (event: IMouseCoords, postAssertions?: (canvasElement: HTMLElement) => void) =>\n        async ({ canvasElement }: { canvasElement: HTMLElement }) => {\n            const eventArgs = { ...event, bubbles: true };\n\n            // Wait for the chart to finish rendering\n            await wait(STORYBOOK_PLAY_DELAY);\n\n            // Find the event reciver\n            const eventReciver = canvasElement.querySelector(\".event-receiver\");\n            expect(eventReciver).toBeDefined();\n\n            fireEvent(eventReciver, new MouseEvent(\"mouseover\", eventArgs));\n            await wait(50);\n\n            if (postAssertions) {\n                postAssertions(canvasElement);\n            }\n        };\n\n/**\n * Creates an interaction test for a Canvas chart\n * @param event     An object containing the mouse coordinates\n * @returns         The Storybook play function\n */\nexport const createCanvasTest =\n    (event: IMouseCoords) =>\n        /**\n         * The actual test\n         * @param { canvasElement, args } The storybook play function interface\n         */\n        async ({ canvasElement, args }: ITestArgs) => {\n            const eventArgs = { ...event, bubbles: true };\n\n            // Wait for the chart to finish rendering\n            await wait(STORYBOOK_PLAY_DELAY);\n\n            // Grab the virtual canvas\n            const virtualCanvas = canvasElement.querySelector(\".virtual-canvas\");\n            expect(virtualCanvas).toBeDefined();\n\n            fireEvent(virtualCanvas, new MouseEvent(\"mousemove\", eventArgs));\n            expect(args.onMouseOver).toHaveBeenCalled();\n            await wait(50);\n\n            fireEvent(virtualCanvas, new MouseEvent(\"click\", eventArgs));\n            expect(args.onClick).toHaveBeenCalled();\n            await wait(50);\n\n            fireEvent(virtualCanvas, new MouseEvent(\"mousemove\", { clientX: 0, clientY: 0, bubbles: true }));\n            expect(args.onMouseOut).toHaveBeenCalled();\n            await wait(50);\n\n            // Add the tooltip back to verify it\n            fireEvent(virtualCanvas, new MouseEvent(\"mousemove\", eventArgs));\n        };\n"],"names":["STORYBOOK_PLAY_DELAY","createSVGTest","selector","event","canvasElement","args","eventArgs","wait","dataPoint","expect","fireEvent","createEventReceiverTest","postAssertions","eventReciver","createCanvasTest","virtualCanvas"],"mappings":"6FAkBA,MAAMA,EAAuB,IAQhBC,EACT,CAACC,EAAkBC,IAKf,MAAO,CAAE,cAAAC,EAAe,KAAAC,KAAsB,CAC1C,MAAMC,EAAY,CAAE,GAAGH,EAAO,QAAS,EAAK,EAG5C,MAAMI,EAAKP,CAAoB,EAGzB,MAAAQ,EAAYJ,EAAc,cAAcF,CAAQ,EAC/CO,EAAAD,CAAS,EAAE,YAAY,EAE9BE,EAAUF,EAAW,IAAI,WAAW,YAAaF,CAAS,CAAC,EACpDG,EAAAJ,EAAK,WAAW,EAAE,iBAAiB,EAE1CK,EAAUF,EAAW,IAAI,WAAW,QAASF,CAAS,CAAC,EAChDG,EAAAJ,EAAK,OAAO,EAAE,iBAAiB,EAEtCK,EAAUF,EAAW,IAAI,WAAW,WAAYF,CAAS,CAAC,EACnDG,EAAAJ,EAAK,UAAU,EAAE,iBAAiB,EAGzCK,EAAUF,EAAW,IAAI,WAAW,YAAaF,CAAS,CAAC,EACpDG,EAAAJ,EAAK,WAAW,EAAE,iBAAiB,CAAA,EASzCM,EACT,CAACR,EAAqBS,IAClB,MAAO,CAAE,cAAAR,KAAoD,CACzD,MAAME,EAAY,CAAE,GAAGH,EAAO,QAAS,EAAK,EAG5C,MAAMI,EAAKP,CAAoB,EAGzB,MAAAa,EAAeT,EAAc,cAAc,iBAAiB,EAC3DK,EAAAI,CAAY,EAAE,YAAY,EAEjCH,EAAUG,EAAc,IAAI,WAAW,YAAaP,CAAS,CAAC,EAC9D,MAAMC,EAAK,EAAE,EAETK,GACAA,EAAeR,CAAa,CAEpC,EAOKU,EACRX,GAKG,MAAO,CAAE,cAAAC,EAAe,KAAAC,KAAsB,CAC1C,MAAMC,EAAY,CAAE,GAAGH,EAAO,QAAS,EAAK,EAG5C,MAAMI,EAAKP,CAAoB,EAGzB,MAAAe,EAAgBX,EAAc,cAAc,iBAAiB,EAC5DK,EAAAM,CAAa,EAAE,YAAY,EAElCL,EAAUK,EAAe,IAAI,WAAW,YAAaT,CAAS,CAAC,EACxDG,EAAAJ,EAAK,WAAW,EAAE,iBAAiB,EAC1C,MAAME,EAAK,EAAE,EAEbG,EAAUK,EAAe,IAAI,WAAW,QAAST,CAAS,CAAC,EACpDG,EAAAJ,EAAK,OAAO,EAAE,iBAAiB,EACtC,MAAME,EAAK,EAAE,EAEbG,EAAUK,EAAe,IAAI,WAAW,YAAa,CAAE,QAAS,EAAG,QAAS,EAAG,QAAS,EAAM,CAAA,CAAC,EACxFN,EAAAJ,EAAK,UAAU,EAAE,iBAAiB,EACzC,MAAME,EAAK,EAAE,EAGbG,EAAUK,EAAe,IAAI,WAAW,YAAaT,CAAS,CAAC,CAAA"}