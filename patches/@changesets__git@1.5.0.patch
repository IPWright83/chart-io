diff --git a/dist/git.cjs.dev.js b/dist/git.cjs.dev.js
index 40cfe7b25d85c2adcfc6d5f984c05cdbbc3ccccd..49d0798d5b58cf8c1a0d2dfde288b4c9b330da3b 100644
--- a/dist/git.cjs.dev.js
+++ b/dist/git.cjs.dev.js
@@ -1,27 +1,29 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, "__esModule", { value: true });
 
-var spawn = require('spawndamnit');
-var fs = require('fs');
-var path = require('path');
-var getPackages = require('@manypkg/get-packages');
-var errors = require('@changesets/errors');
-var isSubdir = require('is-subdir');
-var util = require('util');
+var spawn = require("spawndamnit");
+var fs = require("fs");
+var path = require("path");
+var getPackages = require("@manypkg/get-packages");
+var errors = require("@changesets/errors");
+var isSubdir = require("is-subdir");
+var util = require("util");
 
-function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
+function _interopDefault(e) {
+  return e && e.__esModule ? e : { default: e };
+}
 
-var spawn__default = /*#__PURE__*/_interopDefault(spawn);
-var fs__default = /*#__PURE__*/_interopDefault(fs);
-var path__default = /*#__PURE__*/_interopDefault(path);
-var isSubdir__default = /*#__PURE__*/_interopDefault(isSubdir);
+var spawn__default = /*#__PURE__*/ _interopDefault(spawn);
+var fs__default = /*#__PURE__*/ _interopDefault(fs);
+var path__default = /*#__PURE__*/ _interopDefault(path);
+var isSubdir__default = /*#__PURE__*/ _interopDefault(isSubdir);
 
-const isInDir = dir => subdir => isSubdir__default['default'](dir, subdir);
+const isInDir = (dir) => (subdir) => isSubdir__default["default"](dir, subdir);
 
 async function add(pathToFile, cwd) {
-  const gitCmd = await spawn__default['default']("git", ["add", pathToFile], {
-    cwd
+  const gitCmd = await spawn__default["default"]("git", ["add", pathToFile], {
+    cwd,
   });
 
   if (gitCmd.code !== 0) {
@@ -31,14 +33,14 @@ async function add(pathToFile, cwd) {
   return gitCmd.code === 0;
 }
 async function commit(message, cwd) {
-  const gitCmd = await spawn__default['default']("git", ["commit", "-m", message, "--allow-empty"], {
-    cwd
+  const gitCmd = await spawn__default["default"]("git", ["commit", "-m", message, "--allow-empty"], {
+    cwd,
   });
   return gitCmd.code === 0;
 }
 async function getAllTags(cwd) {
-  const gitCmd = await spawn__default['default']("git", ["tag"], {
-    cwd
+  const gitCmd = await spawn__default["default"]("git", ["tag"], {
+    cwd,
   });
 
   if (gitCmd.code !== 0) {
@@ -52,15 +54,19 @@ async function getAllTags(cwd) {
 async function tag(tagStr, cwd) {
   // NOTE: it's important we use the -m flag to create annotated tag otherwise 'git push --follow-tags' won't actually push
   // the tags
-  const gitCmd = await spawn__default['default']("git", ["tag", tagStr, "-m", tagStr], {
-    cwd
+  const gitCmd = await spawn__default["default"]("git", ["tag", tagStr, "-m", tagStr], {
+    cwd,
   });
+
+  console.log("stdout: " + gitCmd.stdout);
+  console.log("stderr: " + gitCmd.stderr);
+
   return gitCmd.code === 0;
 } // Find the commit where we diverged from `ref` at using `git merge-base`
 
 async function getDivergedCommit(cwd, ref) {
-  const cmd = await spawn__default['default']("git", ["merge-base", ref, "HEAD"], {
-    cwd
+  const cmd = await spawn__default["default"]("git", ["merge-base", ref, "HEAD"], {
+    cwd,
   });
 
   if (cmd.code !== 0) {
@@ -87,16 +93,26 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
 
   do {
     // Fetch commit information for all paths we don't have yet
-    const commitInfos = await Promise.all(remaining.map(async gitPath => {
-      const [commitSha, parentSha] = (await spawn__default['default']("git", ["log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath], {
-        cwd
-      })).stdout.toString().split(":");
-      return {
-        path: gitPath,
-        commitSha,
-        parentSha
-      };
-    })); // To collect commits without parents (usually because they're absent from
+    const commitInfos = await Promise.all(
+      remaining.map(async (gitPath) => {
+        const [commitSha, parentSha] = (
+          await spawn__default["default"](
+            "git",
+            ["log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath],
+            {
+              cwd,
+            }
+          )
+        ).stdout
+          .toString()
+          .split(":");
+        return {
+          path: gitPath,
+          commitSha,
+          parentSha,
+        };
+      })
+    ); // To collect commits without parents (usually because they're absent from
     // a shallow clone).
 
     let commitsWithMissingParents = [];
@@ -119,16 +135,17 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
     // a shallow clone.
     // Can we deepen the clone?
 
-
-    if (await isRepoShallow({
-      cwd
-    })) {
+    if (
+      await isRepoShallow({
+        cwd,
+      })
+    ) {
       // Yes.
       await deepenCloneBy({
         by: 50,
-        cwd
+        cwd,
       });
-      remaining = commitsWithMissingParents.map(p => p.path);
+      remaining = commitsWithMissingParents.map((p) => p.path);
     } else {
       // It's not a shallow clone, so all the commit SHAs we have are legitimate.
       for (const unresolved of commitsWithMissingParents) {
@@ -139,49 +156,46 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
     }
   } while (true);
 
-  return gitPaths.map(p => map.get(p));
+  return gitPaths.map((p) => map.get(p));
 }
-async function isRepoShallow({
-  cwd
-}) {
-  const isShallowRepoOutput = (await spawn__default['default']("git", ["rev-parse", "--is-shallow-repository"], {
-    cwd
-  })).stdout.toString().trim();
+async function isRepoShallow({ cwd }) {
+  const isShallowRepoOutput = (
+    await spawn__default["default"]("git", ["rev-parse", "--is-shallow-repository"], {
+      cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 
   if (isShallowRepoOutput === "--is-shallow-repository") {
     // We have an old version of Git (<2.15) which doesn't support `rev-parse --is-shallow-repository`
     // In that case, we'll test for the existence of .git/shallow.
     // Firstly, find the .git folder for the repo; note that this will be relative to the repo dir
-    const gitDir = (await spawn__default['default']("git", ["rev-parse", "--git-dir"], {
-      cwd
-    })).stdout.toString().trim();
-    const fullGitDir = path__default['default'].resolve(cwd, gitDir); // Check for the existence of <gitDir>/shallow
-
-    return fs__default['default'].existsSync(path__default['default'].join(fullGitDir, "shallow"));
+    const gitDir = (
+      await spawn__default["default"]("git", ["rev-parse", "--git-dir"], {
+        cwd,
+      })
+    ).stdout
+      .toString()
+      .trim();
+    const fullGitDir = path__default["default"].resolve(cwd, gitDir); // Check for the existence of <gitDir>/shallow
+
+    return fs__default["default"].existsSync(path__default["default"].join(fullGitDir, "shallow"));
   } else {
     // We have a newer Git which supports `rev-parse --is-shallow-repository`. We'll use
     // the output of that instead of messing with .git/shallow in case that changes in the future.
     return isShallowRepoOutput === "true";
   }
 }
-async function deepenCloneBy({
-  by,
-  cwd
-}) {
-  await spawn__default['default']("git", ["fetch", `--deepen=${by}`], {
-    cwd
+async function deepenCloneBy({ by, cwd }) {
+  await spawn__default["default"]("git", ["fetch", `--deepen=${by}`], {
+    cwd,
   });
 }
 
-async function getRepoRoot({
-  cwd
-}) {
-  const {
-    stdout,
-    code,
-    stderr
-  } = await spawn__default['default']("git", ["rev-parse", "--show-toplevel"], {
-    cwd
+async function getRepoRoot({ cwd }) {
+  const { stdout, code, stderr } = await spawn__default["default"]("git", ["rev-parse", "--show-toplevel"], {
+    cwd,
   });
 
   if (code !== 0) {
@@ -191,84 +205,86 @@ async function getRepoRoot({
   return stdout.toString().trim().replace(/\n|\r/g, "");
 }
 
-async function getChangedFilesSince({
-  cwd,
-  ref,
-  fullPath = false
-}) {
+async function getChangedFilesSince({ cwd, ref, fullPath = false }) {
   const divergedAt = await getDivergedCommit(cwd, ref); // Now we can find which files we added
 
-  const cmd = await spawn__default['default']("git", ["diff", "--name-only", divergedAt], {
-    cwd
+  const cmd = await spawn__default["default"]("git", ["diff", "--name-only", divergedAt], {
+    cwd,
   });
 
   if (cmd.code !== 0) {
     throw new Error(`Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`);
   }
 
-  const files = cmd.stdout.toString().trim().split("\n").filter(a => a);
+  const files = cmd.stdout
+    .toString()
+    .trim()
+    .split("\n")
+    .filter((a) => a);
   if (!fullPath) return files;
   const repoRoot = await getRepoRoot({
-    cwd
+    cwd,
   });
-  return files.map(file => path__default['default'].resolve(repoRoot, file));
+  return files.map((file) => path__default["default"].resolve(repoRoot, file));
 } // below are less generic functions that we use in combination with other things we are doing
 
-async function getChangedChangesetFilesSinceRef({
-  cwd,
-  ref
-}) {
+async function getChangedChangesetFilesSinceRef({ cwd, ref }) {
   try {
     const divergedAt = await getDivergedCommit(cwd, ref); // Now we can find which files we added
 
-    const cmd = await spawn__default['default']("git", ["diff", "--name-only", "--diff-filter=d", divergedAt], {
-      cwd
+    const cmd = await spawn__default["default"]("git", ["diff", "--name-only", "--diff-filter=d", divergedAt], {
+      cwd,
     });
     let tester = /.changeset\/[^/]+\.md$/;
-    const files = cmd.stdout.toString().trim().split("\n").filter(file => tester.test(file));
+    const files = cmd.stdout
+      .toString()
+      .trim()
+      .split("\n")
+      .filter((file) => tester.test(file));
     return files;
   } catch (err) {
     if (err instanceof errors.GitError) return [];
     throw err;
   }
 }
-async function getChangedPackagesSinceRef({
-  cwd,
-  ref
-}) {
+async function getChangedPackagesSinceRef({ cwd, ref }) {
   const changedFiles = await getChangedFilesSince({
     ref,
     cwd,
-    fullPath: true
+    fullPath: true,
   });
   let packages = await getPackages.getPackages(cwd);
   const fileToPackage = {};
-  packages.packages.forEach(pkg => changedFiles.filter(isInDir(pkg.dir)).forEach(fileName => {
-    const prevPkg = fileToPackage[fileName] || {
-      dir: ""
-    };
-    if (pkg.dir.length > prevPkg.dir.length) fileToPackage[fileName] = pkg;
-  }));
+  packages.packages.forEach((pkg) =>
+    changedFiles.filter(isInDir(pkg.dir)).forEach((fileName) => {
+      const prevPkg = fileToPackage[fileName] || {
+        dir: "",
+      };
+      if (pkg.dir.length > prevPkg.dir.length) fileToPackage[fileName] = pkg;
+    })
+  );
   return Object.values(fileToPackage) // filter, so that we have only unique packages
-  .filter((pkg, idx, packages) => packages.indexOf(pkg) === idx);
+    .filter((pkg, idx, packages) => packages.indexOf(pkg) === idx);
 }
 async function tagExists(tagStr, cwd) {
-  const gitCmd = await spawn__default['default']("git", ["tag", "-l", tagStr], {
-    cwd
+  const gitCmd = await spawn__default["default"]("git", ["tag", "-l", tagStr], {
+    cwd,
   });
   const output = gitCmd.stdout.toString().trim();
   const tagExists = !!output;
   return tagExists;
 }
-async function getCurrentCommitId({
-  cwd
-}) {
-  return (await spawn__default['default']("git", ["rev-parse", "--short", "HEAD"], {
-    cwd
-  })).stdout.toString().trim();
+async function getCurrentCommitId({ cwd }) {
+  return (
+    await spawn__default["default"]("git", ["rev-parse", "--short", "HEAD"], {
+      cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 }
 async function remoteTagExists(tagStr) {
-  const gitCmd = await spawn__default['default']("git", ["ls-remote", "--tags", "origin", "-l", tagStr]);
+  const gitCmd = await spawn__default["default"]("git", ["ls-remote", "--tags", "origin", "-l", tagStr]);
   const output = gitCmd.stdout.toString().trim();
   const tagExists = !!output;
   return tagExists;
diff --git a/dist/git.cjs.prod.js b/dist/git.cjs.prod.js
index 711c0cbc97d8b5a2a77f0f8f773e4eab490368ca..bab1baae34669bc6a344cef7ec8d7f27fb0aeefc 100644
--- a/dist/git.cjs.prod.js
+++ b/dist/git.cjs.prod.js
@@ -1,37 +1,53 @@
 "use strict";
 
 Object.defineProperty(exports, "__esModule", {
-  value: !0
+  value: !0,
 });
 
-var spawn = require("spawndamnit"), fs = require("fs"), path = require("path"), getPackages = require("@manypkg/get-packages"), errors = require("@changesets/errors"), isSubdir = require("is-subdir"), util = require("util");
+var spawn = require("spawndamnit"),
+  fs = require("fs"),
+  path = require("path"),
+  getPackages = require("@manypkg/get-packages"),
+  errors = require("@changesets/errors"),
+  isSubdir = require("is-subdir"),
+  util = require("util");
 
 function _interopDefault(e) {
-  return e && e.__esModule ? e : {
-    default: e
-  };
+  return e && e.__esModule
+    ? e
+    : {
+        default: e,
+      };
 }
 
-var spawn__default = _interopDefault(spawn), fs__default = _interopDefault(fs), path__default = _interopDefault(path), isSubdir__default = _interopDefault(isSubdir);
+var spawn__default = _interopDefault(spawn),
+  fs__default = _interopDefault(fs),
+  path__default = _interopDefault(path),
+  isSubdir__default = _interopDefault(isSubdir);
 
-const isInDir = dir => subdir => isSubdir__default.default(dir, subdir);
+const isInDir = (dir) => (subdir) => isSubdir__default.default(dir, subdir);
 
 async function add(pathToFile, cwd) {
-  const gitCmd = await spawn__default.default("git", [ "add", pathToFile ], {
-    cwd: cwd
+  const gitCmd = await spawn__default.default("git", ["add", pathToFile], {
+    cwd: cwd,
   });
   return 0 !== gitCmd.code && console.log(pathToFile, gitCmd.stderr.toString()), 0 === gitCmd.code;
 }
 
 async function commit(message, cwd) {
-  return 0 === (await spawn__default.default("git", [ "commit", "-m", message, "--allow-empty" ], {
-    cwd: cwd
-  })).code;
+  return (
+    0 ===
+    (
+      await spawn__default.default("git", ["commit", "-m", message, "--allow-empty"], {
+        cwd: cwd,
+      })
+    ).code
+  );
 }
 
 async function getAllTags(cwd) {
-  const gitCmd = await spawn__default.default("git", [ "tag" ], {
-    cwd: cwd
+  const gitCmd = await spawn__default.default("git", ["tag"], {
+    cwd: cwd,
   });
   if (0 !== gitCmd.code) throw new Error(gitCmd.stderr.toString());
   const tags = gitCmd.stdout.toString().trim().split("\n");
@@ -39,144 +55,212 @@ async function getAllTags(cwd) {
 }
 
 async function tag(tagStr, cwd) {
-  return 0 === (await spawn__default.default("git", [ "tag", tagStr, "-m", tagStr ], {
-    cwd: cwd
-  })).code;
+  const gitCmd = await spawn__default.default("git", ["tag", tagStr, "-m", tagStr], {
+    cwd: cwd,
+  });
+
+  console.log("stdout: " + gitCmd.stdout);
+  console.log("stderr: " + gitCmd.stderr);
+
+  return 0 === gitCmd.code;
 }
 
 async function getDivergedCommit(cwd, ref) {
-  const cmd = await spawn__default.default("git", [ "merge-base", ref, "HEAD" ], {
-    cwd: cwd
+  const cmd = await spawn__default.default("git", ["merge-base", ref, "HEAD"], {
+    cwd: cwd,
   });
   if (0 !== cmd.code) throw new Error(`Failed to find where HEAD diverged from ${ref}. Does ${ref} exist?`);
   return cmd.stdout.toString().trim();
 }
 
-const getCommitThatAddsFile = util.deprecate((async (gitPath, cwd) => (await getCommitsThatAddFiles([ gitPath ], cwd))[0]), "Use the bulk getCommitsThatAddFiles function instead");
+const getCommitThatAddsFile = util.deprecate(
+  async (gitPath, cwd) => (await getCommitsThatAddFiles([gitPath], cwd))[0],
+  "Use the bulk getCommitsThatAddFiles function instead"
+);
 
 async function getCommitsThatAddFiles(gitPaths, cwd) {
-  const map = new Map;
+  const map = new Map();
   let remaining = gitPaths;
   for (;;) {
-    const commitInfos = await Promise.all(remaining.map((async gitPath => {
-      const [commitSha, parentSha] = (await spawn__default.default("git", [ "log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath ], {
-        cwd: cwd
-      })).stdout.toString().split(":");
-      return {
-        path: gitPath,
-        commitSha: commitSha,
-        parentSha: parentSha
-      };
-    })));
+    const commitInfos = await Promise.all(
+      remaining.map(async (gitPath) => {
+        const [commitSha, parentSha] = (
+          await spawn__default.default(
+            "git",
+            ["log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath],
+            {
+              cwd: cwd,
+            }
+          )
+        ).stdout
+          .toString()
+          .split(":");
+        return {
+          path: gitPath,
+          commitSha: commitSha,
+          parentSha: parentSha,
+        };
+      })
+    );
     let commitsWithMissingParents = [];
-    for (const info of commitInfos) info.commitSha && (info.parentSha ? map.set(info.path, info.commitSha) : commitsWithMissingParents.push(info));
+    for (const info of commitInfos)
+      info.commitSha && (info.parentSha ? map.set(info.path, info.commitSha) : commitsWithMissingParents.push(info));
     if (0 === commitsWithMissingParents.length) break;
-    if (!await isRepoShallow({
-      cwd: cwd
-    })) {
+    if (
+      !(await isRepoShallow({
+        cwd: cwd,
+      }))
+    ) {
       for (const unresolved of commitsWithMissingParents) map.set(unresolved.path, unresolved.commitSha);
       break;
     }
     await deepenCloneBy({
       by: 50,
-      cwd: cwd
-    }), remaining = commitsWithMissingParents.map((p => p.path));
+      cwd: cwd,
+    }),
+      (remaining = commitsWithMissingParents.map((p) => p.path));
   }
-  return gitPaths.map((p => map.get(p)));
+  return gitPaths.map((p) => map.get(p));
 }
 
-async function isRepoShallow({cwd: cwd}) {
-  const isShallowRepoOutput = (await spawn__default.default("git", [ "rev-parse", "--is-shallow-repository" ], {
-    cwd: cwd
-  })).stdout.toString().trim();
+async function isRepoShallow({ cwd: cwd }) {
+  const isShallowRepoOutput = (
+    await spawn__default.default("git", ["rev-parse", "--is-shallow-repository"], {
+      cwd: cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
   if ("--is-shallow-repository" === isShallowRepoOutput) {
-    const gitDir = (await spawn__default.default("git", [ "rev-parse", "--git-dir" ], {
-      cwd: cwd
-    })).stdout.toString().trim(), fullGitDir = path__default.default.resolve(cwd, gitDir);
+    const gitDir = (
+        await spawn__default.default("git", ["rev-parse", "--git-dir"], {
+          cwd: cwd,
+        })
+      ).stdout
+        .toString()
+        .trim(),
+      fullGitDir = path__default.default.resolve(cwd, gitDir);
     return fs__default.default.existsSync(path__default.default.join(fullGitDir, "shallow"));
   }
   return "true" === isShallowRepoOutput;
 }
 
-async function deepenCloneBy({by: by, cwd: cwd}) {
-  await spawn__default.default("git", [ "fetch", "--deepen=" + by ], {
-    cwd: cwd
+async function deepenCloneBy({ by: by, cwd: cwd }) {
+  await spawn__default.default("git", ["fetch", "--deepen=" + by], {
+    cwd: cwd,
   });
 }
 
-async function getRepoRoot({cwd: cwd}) {
-  const {stdout: stdout, code: code, stderr: stderr} = await spawn__default.default("git", [ "rev-parse", "--show-toplevel" ], {
-    cwd: cwd
-  });
+async function getRepoRoot({ cwd: cwd }) {
+  const { stdout: stdout, code: code, stderr: stderr } = await spawn__default.default(
+    "git",
+    ["rev-parse", "--show-toplevel"],
+    {
+      cwd: cwd,
+    }
+  );
   if (0 !== code) throw new Error(stderr.toString());
   return stdout.toString().trim().replace(/\n|\r/g, "");
 }
 
-async function getChangedFilesSince({cwd: cwd, ref: ref, fullPath: fullPath = !1}) {
-  const divergedAt = await getDivergedCommit(cwd, ref), cmd = await spawn__default.default("git", [ "diff", "--name-only", divergedAt ], {
-    cwd: cwd
-  });
+async function getChangedFilesSince({ cwd: cwd, ref: ref, fullPath: fullPath = !1 }) {
+  const divergedAt = await getDivergedCommit(cwd, ref),
+    cmd = await spawn__default.default("git", ["diff", "--name-only", divergedAt], {
+      cwd: cwd,
+    });
   if (0 !== cmd.code) throw new Error(`Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`);
-  const files = cmd.stdout.toString().trim().split("\n").filter((a => a));
+  const files = cmd.stdout
+    .toString()
+    .trim()
+    .split("\n")
+    .filter((a) => a);
   if (!fullPath) return files;
   const repoRoot = await getRepoRoot({
-    cwd: cwd
+    cwd: cwd,
   });
-  return files.map((file => path__default.default.resolve(repoRoot, file)));
+  return files.map((file) => path__default.default.resolve(repoRoot, file));
 }
 
-async function getChangedChangesetFilesSinceRef({cwd: cwd, ref: ref}) {
+async function getChangedChangesetFilesSinceRef({ cwd: cwd, ref: ref }) {
   try {
-    const divergedAt = await getDivergedCommit(cwd, ref), cmd = await spawn__default.default("git", [ "diff", "--name-only", "--diff-filter=d", divergedAt ], {
-      cwd: cwd
-    });
+    const divergedAt = await getDivergedCommit(cwd, ref),
+      cmd = await spawn__default.default("git", ["diff", "--name-only", "--diff-filter=d", divergedAt], {
+        cwd: cwd,
+      });
     let tester = /.changeset\/[^/]+\.md$/;
-    return cmd.stdout.toString().trim().split("\n").filter((file => tester.test(file)));
+    return cmd.stdout
+      .toString()
+      .trim()
+      .split("\n")
+      .filter((file) => tester.test(file));
   } catch (err) {
     if (err instanceof errors.GitError) return [];
     throw err;
   }
 }
 
-async function getChangedPackagesSinceRef({cwd: cwd, ref: ref}) {
+async function getChangedPackagesSinceRef({ cwd: cwd, ref: ref }) {
   const changedFiles = await getChangedFilesSince({
     ref: ref,
     cwd: cwd,
-    fullPath: !0
+    fullPath: !0,
   });
   let packages = await getPackages.getPackages(cwd);
   const fileToPackage = {};
-  return packages.packages.forEach((pkg => {
-    return changedFiles.filter((dir = pkg.dir, subdir => isSubdir__default.default(dir, subdir))).forEach((fileName => {
-      const prevPkg = fileToPackage[fileName] || {
-        dir: ""
-      };
-      pkg.dir.length > prevPkg.dir.length && (fileToPackage[fileName] = pkg);
-    }));
-    var dir;
-  })), Object.values(fileToPackage).filter(((pkg, idx, packages) => packages.indexOf(pkg) === idx));
+  return (
+    packages.packages.forEach((pkg) => {
+      return changedFiles
+        .filter(((dir = pkg.dir), (subdir) => isSubdir__default.default(dir, subdir)))
+        .forEach((fileName) => {
+          const prevPkg = fileToPackage[fileName] || {
+            dir: "",
+          };
+          pkg.dir.length > prevPkg.dir.length && (fileToPackage[fileName] = pkg);
+        });
+      var dir;
+    }),
+    Object.values(fileToPackage).filter((pkg, idx, packages) => packages.indexOf(pkg) === idx)
+  );
 }
 
 async function tagExists(tagStr, cwd) {
-  return !!(await spawn__default.default("git", [ "tag", "-l", tagStr ], {
-    cwd: cwd
-  })).stdout.toString().trim();
+  return !!(
+    await spawn__default.default("git", ["tag", "-l", tagStr], {
+      cwd: cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 }
 
-async function getCurrentCommitId({cwd: cwd}) {
-  return (await spawn__default.default("git", [ "rev-parse", "--short", "HEAD" ], {
-    cwd: cwd
-  })).stdout.toString().trim();
+async function getCurrentCommitId({ cwd: cwd }) {
+  return (
+    await spawn__default.default("git", ["rev-parse", "--short", "HEAD"], {
+      cwd: cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 }
 
 async function remoteTagExists(tagStr) {
-  return !!(await spawn__default.default("git", [ "ls-remote", "--tags", "origin", "-l", tagStr ])).stdout.toString().trim();
+  return !!(await spawn__default.default("git", ["ls-remote", "--tags", "origin", "-l", tagStr])).stdout
+    .toString()
+    .trim();
 }
 
-exports.add = add, exports.commit = commit, exports.deepenCloneBy = deepenCloneBy, 
-exports.getAllTags = getAllTags, exports.getChangedChangesetFilesSinceRef = getChangedChangesetFilesSinceRef, 
-exports.getChangedFilesSince = getChangedFilesSince, exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef, 
-exports.getCommitThatAddsFile = getCommitThatAddsFile, exports.getCommitsThatAddFiles = getCommitsThatAddFiles, 
-exports.getCurrentCommitId = getCurrentCommitId, exports.getDivergedCommit = getDivergedCommit, 
-exports.isRepoShallow = isRepoShallow, exports.remoteTagExists = remoteTagExists, 
-exports.tag = tag, exports.tagExists = tagExists;
+(exports.add = add),
+  (exports.commit = commit),
+  (exports.deepenCloneBy = deepenCloneBy),
+  (exports.getAllTags = getAllTags),
+  (exports.getChangedChangesetFilesSinceRef = getChangedChangesetFilesSinceRef),
+  (exports.getChangedFilesSince = getChangedFilesSince),
+  (exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef),
+  (exports.getCommitThatAddsFile = getCommitThatAddsFile),
+  (exports.getCommitsThatAddFiles = getCommitsThatAddFiles),
+  (exports.getCurrentCommitId = getCurrentCommitId),
+  (exports.getDivergedCommit = getDivergedCommit),
+  (exports.isRepoShallow = isRepoShallow),
+  (exports.remoteTagExists = remoteTagExists),
+  (exports.tag = tag),
+  (exports.tagExists = tagExists);
diff --git a/dist/git.esm.js b/dist/git.esm.js
index 0cc847fb506155b247e7f9ea91900971cef48546..3417fcb5b7e9d2f69e8935d9455aeb132093daac 100644
--- a/dist/git.esm.js
+++ b/dist/git.esm.js
@@ -1,16 +1,16 @@
-import spawn from 'spawndamnit';
-import fs from 'fs';
-import path from 'path';
-import { getPackages } from '@manypkg/get-packages';
-import { GitError } from '@changesets/errors';
-import isSubdir from 'is-subdir';
-import { deprecate } from 'util';
+import spawn from "spawndamnit";
+import fs from "fs";
+import path from "path";
+import { getPackages } from "@manypkg/get-packages";
+import { GitError } from "@changesets/errors";
+import isSubdir from "is-subdir";
+import { deprecate } from "util";
 
-const isInDir = dir => subdir => isSubdir(dir, subdir);
+const isInDir = (dir) => (subdir) => isSubdir(dir, subdir);
 
 async function add(pathToFile, cwd) {
   const gitCmd = await spawn("git", ["add", pathToFile], {
-    cwd
+    cwd,
   });
 
   if (gitCmd.code !== 0) {
@@ -21,13 +21,13 @@ async function add(pathToFile, cwd) {
 }
 async function commit(message, cwd) {
   const gitCmd = await spawn("git", ["commit", "-m", message, "--allow-empty"], {
-    cwd
+    cwd,
   });
   return gitCmd.code === 0;
 }
 async function getAllTags(cwd) {
   const gitCmd = await spawn("git", ["tag"], {
-    cwd
+    cwd,
   });
 
   if (gitCmd.code !== 0) {
@@ -42,14 +42,16 @@ async function tag(tagStr, cwd) {
   // NOTE: it's important we use the -m flag to create annotated tag otherwise 'git push --follow-tags' won't actually push
   // the tags
   const gitCmd = await spawn("git", ["tag", tagStr, "-m", tagStr], {
-    cwd
+    cwd,
   });
+  console.log("stdout: " + gitCmd.stdout);
+  console.log("stderr: " + gitCmd.stderr);
   return gitCmd.code === 0;
 } // Find the commit where we diverged from `ref` at using `git merge-base`
 
 async function getDivergedCommit(cwd, ref) {
   const cmd = await spawn("git", ["merge-base", ref, "HEAD"], {
-    cwd
+    cwd,
   });
 
   if (cmd.code !== 0) {
@@ -76,16 +78,22 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
 
   do {
     // Fetch commit information for all paths we don't have yet
-    const commitInfos = await Promise.all(remaining.map(async gitPath => {
-      const [commitSha, parentSha] = (await spawn("git", ["log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath], {
-        cwd
-      })).stdout.toString().split(":");
-      return {
-        path: gitPath,
-        commitSha,
-        parentSha
-      };
-    })); // To collect commits without parents (usually because they're absent from
+    const commitInfos = await Promise.all(
+      remaining.map(async (gitPath) => {
+        const [commitSha, parentSha] = (
+          await spawn("git", ["log", "--diff-filter=A", "--max-count=1", "--pretty=format:%h:%p", gitPath], {
+            cwd,
+          })
+        ).stdout
+          .toString()
+          .split(":");
+        return {
+          path: gitPath,
+          commitSha,
+          parentSha,
+        };
+      })
+    ); // To collect commits without parents (usually because they're absent from
     // a shallow clone).
 
     let commitsWithMissingParents = [];
@@ -108,16 +116,17 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
     // a shallow clone.
     // Can we deepen the clone?
 
-
-    if (await isRepoShallow({
-      cwd
-    })) {
+    if (
+      await isRepoShallow({
+        cwd,
+      })
+    ) {
       // Yes.
       await deepenCloneBy({
         by: 50,
-        cwd
+        cwd,
       });
-      remaining = commitsWithMissingParents.map(p => p.path);
+      remaining = commitsWithMissingParents.map((p) => p.path);
     } else {
       // It's not a shallow clone, so all the commit SHAs we have are legitimate.
       for (const unresolved of commitsWithMissingParents) {
@@ -128,22 +137,28 @@ async function getCommitsThatAddFiles(gitPaths, cwd) {
     }
   } while (true);
 
-  return gitPaths.map(p => map.get(p));
+  return gitPaths.map((p) => map.get(p));
 }
-async function isRepoShallow({
-  cwd
-}) {
-  const isShallowRepoOutput = (await spawn("git", ["rev-parse", "--is-shallow-repository"], {
-    cwd
-  })).stdout.toString().trim();
+async function isRepoShallow({ cwd }) {
+  const isShallowRepoOutput = (
+    await spawn("git", ["rev-parse", "--is-shallow-repository"], {
+      cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 
   if (isShallowRepoOutput === "--is-shallow-repository") {
     // We have an old version of Git (<2.15) which doesn't support `rev-parse --is-shallow-repository`
     // In that case, we'll test for the existence of .git/shallow.
     // Firstly, find the .git folder for the repo; note that this will be relative to the repo dir
-    const gitDir = (await spawn("git", ["rev-parse", "--git-dir"], {
-      cwd
-    })).stdout.toString().trim();
+    const gitDir = (
+      await spawn("git", ["rev-parse", "--git-dir"], {
+        cwd,
+      })
+    ).stdout
+      .toString()
+      .trim();
     const fullGitDir = path.resolve(cwd, gitDir); // Check for the existence of <gitDir>/shallow
 
     return fs.existsSync(path.join(fullGitDir, "shallow"));
@@ -153,24 +168,15 @@ async function isRepoShallow({
     return isShallowRepoOutput === "true";
   }
 }
-async function deepenCloneBy({
-  by,
-  cwd
-}) {
+async function deepenCloneBy({ by, cwd }) {
   await spawn("git", ["fetch", `--deepen=${by}`], {
-    cwd
+    cwd,
   });
 }
 
-async function getRepoRoot({
-  cwd
-}) {
-  const {
-    stdout,
-    code,
-    stderr
-  } = await spawn("git", ["rev-parse", "--show-toplevel"], {
-    cwd
+async function getRepoRoot({ cwd }) {
+  const { stdout, code, stderr } = await spawn("git", ["rev-parse", "--show-toplevel"], {
+    cwd,
   });
 
   if (code !== 0) {
@@ -180,81 +186,83 @@ async function getRepoRoot({
   return stdout.toString().trim().replace(/\n|\r/g, "");
 }
 
-async function getChangedFilesSince({
-  cwd,
-  ref,
-  fullPath = false
-}) {
+async function getChangedFilesSince({ cwd, ref, fullPath = false }) {
   const divergedAt = await getDivergedCommit(cwd, ref); // Now we can find which files we added
 
   const cmd = await spawn("git", ["diff", "--name-only", divergedAt], {
-    cwd
+    cwd,
   });
 
   if (cmd.code !== 0) {
     throw new Error(`Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`);
   }
 
-  const files = cmd.stdout.toString().trim().split("\n").filter(a => a);
+  const files = cmd.stdout
+    .toString()
+    .trim()
+    .split("\n")
+    .filter((a) => a);
   if (!fullPath) return files;
   const repoRoot = await getRepoRoot({
-    cwd
+    cwd,
   });
-  return files.map(file => path.resolve(repoRoot, file));
+  return files.map((file) => path.resolve(repoRoot, file));
 } // below are less generic functions that we use in combination with other things we are doing
 
-async function getChangedChangesetFilesSinceRef({
-  cwd,
-  ref
-}) {
+async function getChangedChangesetFilesSinceRef({ cwd, ref }) {
   try {
     const divergedAt = await getDivergedCommit(cwd, ref); // Now we can find which files we added
 
     const cmd = await spawn("git", ["diff", "--name-only", "--diff-filter=d", divergedAt], {
-      cwd
+      cwd,
     });
     let tester = /.changeset\/[^/]+\.md$/;
-    const files = cmd.stdout.toString().trim().split("\n").filter(file => tester.test(file));
+    const files = cmd.stdout
+      .toString()
+      .trim()
+      .split("\n")
+      .filter((file) => tester.test(file));
     return files;
   } catch (err) {
     if (err instanceof GitError) return [];
     throw err;
   }
 }
-async function getChangedPackagesSinceRef({
-  cwd,
-  ref
-}) {
+async function getChangedPackagesSinceRef({ cwd, ref }) {
   const changedFiles = await getChangedFilesSince({
     ref,
     cwd,
-    fullPath: true
+    fullPath: true,
   });
   let packages = await getPackages(cwd);
   const fileToPackage = {};
-  packages.packages.forEach(pkg => changedFiles.filter(isInDir(pkg.dir)).forEach(fileName => {
-    const prevPkg = fileToPackage[fileName] || {
-      dir: ""
-    };
-    if (pkg.dir.length > prevPkg.dir.length) fileToPackage[fileName] = pkg;
-  }));
+  packages.packages.forEach((pkg) =>
+    changedFiles.filter(isInDir(pkg.dir)).forEach((fileName) => {
+      const prevPkg = fileToPackage[fileName] || {
+        dir: "",
+      };
+      if (pkg.dir.length > prevPkg.dir.length) fileToPackage[fileName] = pkg;
+    })
+  );
   return Object.values(fileToPackage) // filter, so that we have only unique packages
-  .filter((pkg, idx, packages) => packages.indexOf(pkg) === idx);
+    .filter((pkg, idx, packages) => packages.indexOf(pkg) === idx);
 }
 async function tagExists(tagStr, cwd) {
   const gitCmd = await spawn("git", ["tag", "-l", tagStr], {
-    cwd
+    cwd,
   });
   const output = gitCmd.stdout.toString().trim();
   const tagExists = !!output;
   return tagExists;
 }
-async function getCurrentCommitId({
-  cwd
-}) {
-  return (await spawn("git", ["rev-parse", "--short", "HEAD"], {
-    cwd
-  })).stdout.toString().trim();
+async function getCurrentCommitId({ cwd }) {
+  return (
+    await spawn("git", ["rev-parse", "--short", "HEAD"], {
+      cwd,
+    })
+  ).stdout
+    .toString()
+    .trim();
 }
 async function remoteTagExists(tagStr) {
   const gitCmd = await spawn("git", ["ls-remote", "--tags", "origin", "-l", tagStr]);
@@ -263,4 +271,20 @@ async function remoteTagExists(tagStr) {
   return tagExists;
 }
 
-export { add, commit, deepenCloneBy, getAllTags, getChangedChangesetFilesSinceRef, getChangedFilesSince, getChangedPackagesSinceRef, getCommitThatAddsFile, getCommitsThatAddFiles, getCurrentCommitId, getDivergedCommit, isRepoShallow, remoteTagExists, tag, tagExists };
+export {
+  add,
+  commit,
+  deepenCloneBy,
+  getAllTags,
+  getChangedChangesetFilesSinceRef,
+  getChangedFilesSince,
+  getChangedPackagesSinceRef,
+  getCommitThatAddsFile,
+  getCommitsThatAddFiles,
+  getCurrentCommitId,
+  getDivergedCommit,
+  isRepoShallow,
+  remoteTagExists,
+  tag,
+  tagExists,
+};